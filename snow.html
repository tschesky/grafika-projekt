<!DOCTYPE html> 
 <!-- The previous line tells the browser, that the page uses the HTML5 standard. --> 
  
 <html>
     <head>
         <title>Snow</title> 
         <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"> 
  
         <!-- The following meta line optimizes the site for mobile devices. It sets the viewport size 
       to the screen size, so it will be displayed maximized, but unscaled. --> 
         <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"> 
         <style type="text/css"> 
                  body { 
         /* Set the background color of the HTML page to black */ 
                       background: #000044;
                       margin: 0px;
                       overflow: hidden;
                  } 

                  a {
                  color:#0078ff;
                  }
         </style> 
         <!-- Include two libraries 
       1. Three.js (core library)
       2. Detector.js (checks the browsers WebGL capabilities) --> 
         <script src="three.min.js"></script> 
         <script src="Detector.js"></script> 
         <script src="OrbitControls.js"></script>
         <script> 
            var particles = [];
            var movementPaths = [];
         </script>
     </head> 
     <body>
         <!-- This is the DIV element which will contain the WebGL canvas. To be identifiable lateron, the id 'WebGLCanvas' is applied to it. --> 
         <div id="WebGLCanvas"> </div> 
  
         <!-- This JavaScript block encloses the Three.js commands --> 
         <script> 
           // Global scene object 
           var scene; 

           // Global camera object 
           var camera; 

           // Global mesh object of the pyramid 
           var pyramidMesh; 

           // Global mesh object of the cube 
           var cubeMesh; 

           // Initialize the scene 
           initializeScene(); 

           // Animate the scene 
           animateScene(); 

           /** 
            * Initialze the scene. 
            */ 

            function plusMinusRandomizer() {
              var rand = Math.random();

              if (rand > 0.5) {
                return 1;
              } else {
                return -1;
              }
            }

           function initializeScene(){ 
               // Check whether the browser supports WebGL. If so, instantiate the hardware accelerated 
               // WebGL renderer. For antialiasing, we have to enable it. The canvas renderer uses 
               // antialiasing by default. 
               // The approach of multiplse renderers is quite nice, because your scene can also be 
               // viewed in browsers, which don't support WebGL. The limitations of the canvas renderer 
               // in contrast to the WebGL renderer will be explained in the tutorials, when there is a 
               // difference. 
               if(Detector.webgl){ 
                   renderer = new THREE.WebGLRenderer({antialias:true}); 

               // If its not supported, instantiate the canvas renderer to support all non WebGL browsers 
               } else { 
                   renderer = new THREE.CanvasRenderer(); 
               } 

               // Set the background color of the renderer to black, with full opacity 
               renderer.setClearColor(0x000044, 1); 

               // Get the size of the inner window (content area) to create a full size renderer 
               canvasWidth = window.innerWidth; 
               canvasHeight = window.innerHeight; 

               // Set the renderers size to the content areas size 
               renderer.setSize(canvasWidth, canvasHeight); 

               // Get the DIV element from the HTML document by its ID and append the renderers DOM 
               // object to it 
               document.getElementById("WebGLCanvas").appendChild(renderer.domElement); 



               // Create the scene, in which all objects are stored (e. g. camera, lights, 
               // geometries, ...) 
               scene = new THREE.Scene(); 

               // Add lights
               addLights();

               // SKYBOX
               var urlPrefix = "skybox/";
               var urls = [ urlPrefix + "xpos.png", urlPrefix + "xneg.png", urlPrefix + "ypos.png", urlPrefix + "yneg.png",urlPrefix + "zpos.png", urlPrefix + "zneg.png" ];
               var textureCube = THREE.ImageUtils.loadTextureCube( urls , undefined, function () {
                  var shader = THREE.ShaderLib["cube"];
                  var uniforms = THREE.UniformsUtils.clone( shader.uniforms );
                  shader.uniforms['tCube'].value = textureCube;   // textureCube has been init before
                  var material = new THREE.ShaderMaterial({
                    fragmentShader    : shader.fragmentShader,
                    vertexShader  : shader.vertexShader,
                    uniforms  : shader.uniforms,
                    depthWrite : false,
                    side: THREE.BackSide,
                });
              var geometry = new THREE.BoxGeometry(100, 100, 100)
              var skybox = new THREE.Mesh(geometry, material)
              scene.add(skybox)
              });

               // SKYBOX

              camera = new THREE.PerspectiveCamera(45, canvasWidth / canvasHeight, 1, 100); 
              camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
              camera.position.z = 500;

              controls = new THREE.OrbitControls( camera, renderer.domElement );
              controls.addEventListener( 'change', renderer ); // remove when using animation loop
              // enable animation loop when using damping or autorotation
              //controls.enableDamping = true;
              //controls.dampingFactor = 0.25;
              controls.enableZoom = false;

               camera.position.set(0, 10, 0); 
               camera.lookAt(scene.position); 
               scene.add(camera); 
              //-----------------------------------------------------------------------------------------------------//

               var floorGeometry = new THREE.PlaneGeometry( 10, 10 );
               var floorMaterial = new THREE.MeshPhongMaterial();
               
               texture = THREE.ImageUtils.loadTexture('terrain.jpg', {}, function() {
                  renderScene();
               });

               floorMaterial.map = texture;
               console.log(floorMaterial);
               var floor = new THREE.Mesh( floorGeometry, floorMaterial );
               floor.rotateOnAxis(new THREE.Vector3(1,0, 0).normalize(), -1.57079633);
               scene.add( floor );
        
               for (var i = 0; i < 2000; i++) {

                    var sphereGeometry = new THREE.SphereGeometry(0.01, 0.01, 0.01); 

                     // Applying different materials to the faces is a more difficult than applying one 
                     // material to the whole geometry. We start with creating an array of 
                     // THREE.MeshBasicMaterial. 

                     // Define six colored materials 
                     

                     // Create a MeshFaceMaterial, which allows the cube to have different materials on 
                     // each face 

                     // Create a mesh and insert the geometry and the material. Translate the whole mesh 
                     // by 1.5 on the x axis and by 4 on the z axis and add the mesh to the scene. 
                     sphereMesh = new THREE.Mesh(sphereGeometry, new THREE.MeshBasicMaterial({color:0xFFFFFF})); 
                     sphereMesh.position.x = Math.random() * 5 * plusMinusRandomizer();
                     sphereMesh.position.y = Math.random() * 5 * plusMinusRandomizer();
                     sphereMesh.position.z = Math.random() * 5 * plusMinusRandomizer();

                     particles.push(sphereMesh);
                     movementPaths.push(Math.random()/100 * plusMinusRandomizer());
                     scene.add(sphereMesh); 
                    
               }

           } 

           function addLights() {
              var dirLight = new THREE.DirectionalLight(0xffffff, 1);
              dirLight.position.set(100, 100, 50);
              scene.add(dirLight);
          }

           /** 
            * Animate the scene and call rendering. 
            */ 
           function animateScene(){ 
               // Increase the y rotation of the triangle 
               // pyramidMesh.rotation.y += 0.1; 

               // Decrease the rotation of the cube 


               for(var i = 0; i<particles.length; i++) {

                    if (particles[i].position.y > -5) {
                      particles[i].position.y = particles[i].position.y - 0.03
                      if (particles[i].position.x > -6 && particles[i].position.x < 6) {
                        particles[i].position.x = particles[i].position.x + movementPaths[i];
                      } else {
                        particles[i].position.x = Math.random() * 5 * plusMinusRandomizer();
                      }
                    } else {
                      particles[i].position.y = 4.5;
                      particles[i].position.x = Math.random() * 6 * plusMinusRandomizer();
                    }
                    
                    // particle.updatePhysics(); 
                            
                }

               // Define the function, which is called by the browser supported timer loop. If the 
               // browser tab is not visible, the animation is paused. So 'animateScene()' is called 
               // in a browser controlled loop. 
               requestAnimationFrame(animateScene); 


               // Map the 3D scene down to the 2D screen (render the frame) 
               renderScene(); 
           } 

           /** 
            * Render the scene. Map the 3D world to the 2D screen.
            */ 
           function renderScene(){ 
               renderer.render(scene, camera); 
           } 
       </script> 
     </body> 
</html>